<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- MODIFIED: Title updated -->
    <title>AI Icon Customizer Dashboard</title>
    
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Load Font Awesome CSS ONLY (no .js) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" />
    
    <style>
        /* Custom font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-thumb { background: #9CA3AF; border-radius: 10px; }
        ::-webkit-scrollbar-thumb:hover { background: #6B7280; }

        /* Preview Icon Container */
        #previewIconContainer {
            width: 16rem; /* w-64 */
            height: 16rem; /* h-64 */
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px dashed #D1D5DB;
            transition: all 0.2s;
            overflow: hidden;
            border-radius: 0.5rem;
        }
        
        /* Preview Icon (<i> tag) */
        #previewIcon {
            line-height: 1;
            transition: all 0.2s;
        }

        /* NEW: Gradient Text Styling for Preview */
        .gradient-text {
            background-clip: text;
            -webkit-background-clip: text;
            color: transparent;
        }

        /* Loading Spinner */
        .loader {
            width: 20px;
            height: 20px;
            border: 3px solid #FFF;
            border-bottom-color: transparent;
            border-radius: 50%;
            display: inline-block;
            box-sizing: border-box;
            animation: rotation 1s linear infinite;
        }
        @keyframes rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* NEW: Shimmer animation for AI button */
        .shimmer {
            position: relative;
            overflow: hidden;
        }
        .shimmer::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 200%;
            height: 100%;
            background: linear-gradient(90deg, transparent 25%, rgba(255, 255, 255, 0.4) 50%, transparent 75%);
            /* MODIFIED: Slower, more subtle animation */
            animation: shimmer 4s infinite linear;
        }
        @keyframes shimmer {
            0% {
                transform: translateX(0);
            }
            100% {
                transform: translateX(50%);
            }
        }

        /* Icon Grid (Search Results) */
        .icon-grid-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            aspect-ratio: 1 / 1;
            border: 1px solid #D1D5DB;
            border-radius: 0.5rem;
            transition: all 0.15s;
        }
        .icon-grid-btn:hover { background-color: #F3F4F6; }
        .icon-grid-btn.selected {
            outline: 2px solid #2563EB;
            outline-offset: 2px;
            background-color: #EFF6FF;
        }
        .icon-grid-btn .fa-solid,
        .icon-grid-btn .fa-brands,
        .icon-grid-btn .fa-regular {
            font-size: 1.5rem;
            color: #374151;
            pointer-events: none;
        }

        /* Copy Message Toast */
        #copyMessage {
            transition: opacity 0.3s ease-in-out;
        }

        /* Custom range slider */
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: #E5E7EB; /* gray-200 */
            border-radius: 5px;
            outline: none;
            opacity: 0.7;
            transition: opacity .2s;
        }
        input[type="range"]:hover { opacity: 1; }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #2563EB; /* blue-600 */
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #2563EB;
            border-radius: 50%;
            cursor: pointer;
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800">

    <!-- Dashboard Layout Container -->
    <div class="flex h-screen">
        
        <!-- Left Sidebar: Controls -->
        <!-- MODIFIED: Changed w-96 to w-[28rem] for a wider sidebar -->
        <aside id="sidebar" class="w-[28rem] max-w-full h-full bg-white shadow-lg p-6 overflow-y-auto z-20 absolute md:relative md:translate-x-0 -translate-x-full transition-[width] duration-300 ease-in-out md:transition-all overflow-hidden">
            
            <div id="sidebarContent" class="transition-opacity duration-300">
                <button id="sidebarCloseBtn" class="absolute top-4 right-4 p-2 rounded-full hover:bg-gray-100 text-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <i class="fa-solid fa-xmark fa-lg"></i>
                </button>
                
                <h1 class="text-2xl font-bold text-gray-800 mb-6">Controls</h1>

                <div class="space-y-6">
                    
                    <!-- Icon Selector -->
                    <div>
                        <label for="iconApiSearch" class="block text-sm font-medium text-gray-700 mb-2">Search Icon</label>
                        <div class="flex gap-2">
                            <input type="search" id="iconApiSearch" placeholder="e.g., 'user', 'github'" class="flex-1 px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white">
                            <!-- MODIFIED: AI Button with shimmer, new icon, and new text -->
                            <button id="iconApiSearchBtn" class="flex items-center justify-center bg-blue-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-all w-28 shimmer">
                                <i class="fa-solid fa-wand-magic-sparkles fa-fw mr-1.5"></i>
                                <span class="btn-text">AI Find</span>
                                <span class="loader btn-loader hidden"></span>
                            </button>
                        </div>
                        <p class="text-xs text-gray-500 mt-2">
                            Current: <span id="currentIconName" class="font-medium text-gray-700">No icon selected</span>
                        </p>
                        <div id="geminiIconGrid" class="grid grid-cols-6 gap-2 max-h-48 overflow-y-auto p-2 border border-gray-200 rounded-md mt-4 hidden">
                            <!-- Icon buttons generated by JS -->
                        </div>
                    </div>

                    <!-- NEW: Icon Color (Solid & Gradient) -->
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <label class="block text-sm font-medium text-gray-700">Icon Color</label>
                            <div class="flex items-center">
                                <label for="gradientToggle" class="text-sm text-gray-600 mr-2">Gradient</label>
                                <input type="checkbox" id="gradientToggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            </div>
                        </div>
                        <!-- Color 1 -->
                        <div class="flex items-center gap-3">
                            <input type="color" id="gradientColor1Input" value="#2563EB" class="w-12 h-10 p-1 border-0 rounded-md cursor-pointer">
                            <input type="text" id="gradientColor1Hex" value="#2563EB" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white">
                        </div>
                        <!-- Gradient Controls (Hidden by default) -->
                        <div id="gradientControlsContainer" class="space-y-4 mt-4 hidden">
                            <!-- Color 2 -->
                            <div>
                                <label for="gradientColor2Input" class="block text-sm font-medium text-gray-700 mb-2">Color 2</label>
                                <div class="flex items-center gap-3">
                                    <input type="color" id="gradientColor2Input" value="#9333EA" class="w-12 h-10 p-1 border-0 rounded-md cursor-pointer">
                                    <input type="text" id="gradientColor2Hex" value="#9333EA" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white">
                                </div>
                            </div>
                            <!-- Angle -->
                            <div>
                                <label for="gradientAngleInput" class="block text-sm font-medium text-gray-700 mb-2">Angle (<span id="gradientAngleValue">90</span>°)</label>
                                <input type="range" id="gradientAngleInput" min="0" max="360" value="90" class="w-full">
                            </div>
                        </div>
                    </div>

                    <!-- Size & Padding Controls -->
                    <div>
                        <div class="grid grid-cols-2 gap-4">
                            <div>
                                <label for="iconSize" class="block text-sm font-medium text-gray-700 mb-2">Size (px)</label>
                                <!-- CHANGED: Max size increased -->
                                <input type="number" id="iconSize" value="64" min="16" max="1024" step="8" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white">
                            </div>
                            <div>
                                <label for="iconPadding" class="block text-sm font-medium text-gray-700 mb-2">Padding (px)</label>
                                <input type="number" id="iconPadding" value="12" min="0" max="256" step="1" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white">
                            </div>
                        </div>
                        <!-- NEW: Helper text for size -->
                        <p class="text-xs text-gray-500 mt-2">
                            Pixel-perfect export. Total image size = Size + (Padding × 2).
                        </p>
                    </div>

                    <!-- Background Controls -->
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <label class="block text-sm font-medium text-gray-700">Background</label>
                            <div class="flex items-center">
                                <label for="bgToggle" class="text-sm text-gray-600 mr-2">Enable</label>
                                <input type="checkbox" id="bgToggle" class="h-4 w-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500">
                            </div>
                        </div>
                        
                        <div id="bgColorContainer" class="space-y-4 hidden">
                            <!-- Background Color -->
                            <div>
                                <label for="bgColor" class="block text-sm font-medium text-gray-700 mb-2">Background Color</label>
                                <div class="flex items-center gap-3">
                                    <input type="color" id="bgColor" value="#FFFFFF" class="w-12 h-10 p-1 border-0 rounded-md cursor-pointer">
                                    <input type="text" id="bgColorHex" value="#FFFFFF" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 bg-white">
                                </div>
                            </div>
                            <!-- Background Shape -->
                            <div>
                                <label class="block text-sm font-medium text-gray-700 mb-2">Background Shape</label>
                                <div class="flex justify-around text-sm">
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="radio" name="bgShape" value="circle" checked class="text-blue-600 focus:ring-blue-500">
                                        Circle
                                    </label>
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="radio" name="bgShape" value="rounded" class="text-blue-600 focus:ring-blue-500">
                                        Rounded
                                    </label>
                                    <label class="flex items-center gap-2 cursor-pointer">
                                        <input type="radio" name="bgShape" value="square" class="text-blue-600 focus:ring-blue-500">
                                        Square
                                    </label>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- NEW: Presets & Randomizer -->
                    <div class="border-t border-gray-200 pt-6 space-y-4">
                        <label class="block text-sm font-medium text-gray-700">Style Presets</label>
                        <div class="grid grid-cols-2 gap-2">
                             <button id="presetClassic" class="text-sm py-2 px-3 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 transition-all">Classic Blue</button>
                             <button id="presetSunset" class="text-sm py-2 px-3 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 transition-all">Sunset</button>
                             <button id="presetGithub" class="text-sm py-2 px-3 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 transition-all">GitHub</button>
                             <button id="presetRandom" class="text-sm py-2 px-3 bg-gray-100 text-gray-700 rounded-md hover:bg-gray-200 transition-all">
                                <i class="fa-solid fa-dice fa-fw mr-1"></i> Random
                             </button>
                        </div>
                    </div>

                    <!-- Reset Controls Button -->
                    <div class="border-t border-gray-200 pt-6">
                        <button id="resetControlsBtn" class="w-full flex items-center justify-center bg-gray-200 text-gray-700 font-medium py-2 px-4 rounded-lg shadow-sm hover:bg-gray-300 focus:outline-none focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75 transition-all">
                            <i class="fa-solid fa-rotate-left fa-fw mr-2"></i>
                            Reset Controls
                        </button>
                    </div>

                    <!-- NEW: Developer Credit -->
                    <div class="border-t border-gray-200 pt-6 text-center">
                        <p class="text-xs text-gray-500">
                            Developed with <i class="fa-solid fa-heart text-red-500"></i> by Himangshu
                        </p>
                    </div>

                </div>
            </div> <!-- End #sidebarContent wrapper -->
        </aside>

        <!-- Sidebar Overlay for mobile -->
        <div id="sidebarOverlay" class="hidden md:hidden fixed inset-0 bg-black bg-opacity-50 z-10"></div>

        <!-- Desktop Sidebar Open "Pull" Button -->
        <button id="desktopSidebarOpenBtn" class="hidden fixed top-1/2 -translate-y-1/2 left-2 z-30 p-2 bg-white rounded-full shadow-lg hover:bg-gray-100 text-gray-700">
            <i class="fa-solid fa-chevron-right fa-lg"></i>
        </button>

        <!-- Right Panel: Preview & Export -->
        <div class="flex-1 flex flex-col overflow-hidden min-w-0">
            <!-- Top Navbar -->
            <header class="w-full bg-white shadow-md h-16 flex-shrink-0 z-10">
                <div class="flex items-center justify-between h-full px-6">
                    <button id="sidebarToggle" class="p-2 -ml-2 rounded-full hover:bg-gray-100 text-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 md:hidden">
                        <i class="fa-solid fa-bars fa-lg"></i>
                    </button>
                    <h1 class="text-xl font-bold text-gray-800 hidden md:block">
                        <!-- MODIFIED: Title updated -->
                        AI Icon Customizer Dashboard
                    </h1>
                    <div class="flex-1"></div>
                    <!-- Export Buttons -->
                    <div class="flex gap-4">
                        <button id="exportJpg" class="flex items-center bg-blue-600 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-75 transition-all opacity-50 cursor-not-allowed">
                            <i class="fa-solid fa-file-image fa-fw mr-0 sm:mr-2"></i>
                            <span class="hidden sm:inline">Export JPG</span>
                        </button>
                        <button id="exportPng" class="flex items-center bg-gray-700 text-white font-medium py-2 px-4 rounded-lg shadow-md hover:bg-gray-800 focus:outline-none focus:ring-2 focus:ring-gray-500 focus:ring-opacity-75 transition-all opacity-50 cursor-not-allowed">
                            <i class="fa-solid fa-file-image fa-fw mr-0 sm:mr-2"></i>
                            <span class="hidden sm:inline">Export PNG</span>
                        </button>
                    </div>
                </div>
            </header>

            <!-- Main Content Area -->
            <main class="flex-1 overflow-y-auto p-8 lg:p-12">
                <h2 class="text-xl font-semibold text-gray-700 mb-6">Preview</h2>
                
                <div class="flex-grow flex items-center justify-center bg-gray-50 rounded-xl border border-gray-200 p-4 min-h-[300px] mb-8">
                    <div id="previewIconContainer">
                        <!-- MODIFICATION: Replaced single icon with two separate ones -->
                        <i id="previewIconSolid" class="hidden"></i>
                        <i id="previewIconGradient" class="hidden gradient-text"></i>
                    </div>
                </div>

                <!-- Copy Buttons Section -->
                <div class="max-w-md mx-auto grid grid-cols-2 gap-4">
                    <button id="copyClassBtn" class="flex items-center justify-center bg-white text-gray-700 font-medium py-2 px-4 rounded-lg shadow-md border border-gray-300 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all opacity-50 cursor-not-allowed">
                        <i class="fa-solid fa-clipboard fa-fw mr-2"></i>
                        Copy Class
                    </button>
                    <button id="copyUnicodeBtn" class="flex items-center justify-center bg-white text-gray-700 font-medium py-2 px-4 rounded-lg shadow-md border border-gray-300 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-blue-500 transition-all opacity-50 cursor-not-allowed">
                        <i class="fa-solid fa-hashtag fa-fw mr-2"></i>
                        Copy Unicode
                    </button>
                </div>
                <!-- Copy Message Toast -->
                <div id="copyMessage" class="fixed bottom-8 left-1/2 -translate-x-1/2 bg-gray-900 text-white py-2 px-4 rounded-lg shadow-lg opacity-0 pointer-events-none">
                    Copied to clipboard!
                </div>

            </main>
        </div>
    </div>

    <!-- Hidden elements -->
    <a id="downloadLink" style="display: none;"></a>
    <canvas id="exportCanvas" style="display: none;"></canvas>
    <textarea id="clipboardFallback" class="fixed -top-96" aria-hidden="true"></textarea>

    <!-- Error Modal -->
    <div id="errorModal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center p-4 z-50">
        <div class="bg-white p-6 rounded-lg shadow-xl max-w-sm w-full">
            <h3 id="errorTitle" class="text-lg font-medium text-red-700 mb-2">Error</h3>
            <p id="errorMessage" class="text-sm text-gray-600 mb-4">An error occurred.</p>
            <button id="closeErrorModal" class="w-full bg-red-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-red-700 transition-all">
                Close
            </button>
        </div>
    </div>
    
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="hidden fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-40">
        <div class="loader" style="width: 50px; height: 50px; border-width: 5px;"></div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- State Variables ---
            let currentIcon = null; 
            
            // Default control values
            const defaultControls = {
                gradientColor1: '#2563EB',
                gradientColor2: '#9333EA',
                isGradient: false,
                gradientAngle: 90,
                size: 64,
                padding: 12,
                bgColor: '#FFFFFF',
                bgEnabled: false,
                bgShape: 'circle'
            };
            
            // NEW: Presets Definition
            const presets = {
                'classic': { ...defaultControls },
                'sunset': {
                    gradientColor1: '#F97316', gradientColor2: '#D946EF', isGradient: true, gradientAngle: 140,
                    size: 80, padding: 20,
                    bgColor: '#1E293B', bgEnabled: true, bgShape: 'circle'
                },
                'github': {
                    gradientColor1: '#1F2937', gradientColor2: '#1F2937', isGradient: false, gradientAngle: 90,
                    size: 128, padding: 24,
                    bgColor: '#F9FAFB', bgEnabled: true, bgShape: 'rounded'
                }
            };

            // Current style state
            let currentGradientColor1 = defaultControls.gradientColor1;
            let currentGradientColor2 = defaultControls.gradientColor2;
            let isGradient = defaultControls.isGradient;
            let currentGradientAngle = defaultControls.gradientAngle;
            let currentSize = defaultControls.size;
            let currentPadding = defaultControls.padding;
            let currentBgColor = defaultControls.bgColor;
            let isBgEnabled = defaultControls.bgEnabled;
            let currentBgShape = defaultControls.bgShape;
            
            // UI state
            let isMobileSidebarOpen = false;
            let isDesktopSidebarOpen = true; 
            let copyTimeout = null;

            // --- DOM Elements ---
            const previewIconContainer = document.getElementById('previewIconContainer');
            // MODIFICATION: Get both new icon elements
            const previewIconSolid = document.getElementById('previewIconSolid');
            const previewIconGradient = document.getElementById('previewIconGradient');
            const currentIconName = document.getElementById('currentIconName');
            
            // Icon Search
            const iconApiSearch = document.getElementById('iconApiSearch');
            const iconApiSearchBtn = document.getElementById('iconApiSearchBtn');
            const geminiIconGrid = document.getElementById('geminiIconGrid'); 

            // Export
            const exportJpgBtn = document.getElementById('exportJpg');
            const exportPngBtn = document.getElementById('exportPng');
            
            // Hidden Helpers
            const downloadLink = document.getElementById('downloadLink');
            const canvas = document.getElementById('exportCanvas');
            const ctx = canvas.getContext('2d');
            const clipboardFallback = document.getElementById('clipboardFallback');

            // Modals & Overlays
            const errorModal = document.getElementById('errorModal');
            const errorTitle = document.getElementById('errorTitle');
            const errorMessage = document.getElementById('errorMessage');
            const closeErrorModal = document.getElementById('closeErrorModal');
            const loadingOverlay = document.getElementById('loadingOverlay');

            // NEW: Color Controls
            const gradientToggle = document.getElementById('gradientToggle');
            const gradientControlsContainer = document.getElementById('gradientControlsContainer');
            const gradientColor1Input = document.getElementById('gradientColor1Input');
            const gradientColor1Hex = document.getElementById('gradientColor1Hex');
            const gradientColor2Input = document.getElementById('gradientColor2Input');
            const gradientColor2Hex = document.getElementById('gradientColor2Hex');
            const gradientAngleInput = document.getElementById('gradientAngleInput');
            const gradientAngleValue = document.getElementById('gradientAngleValue');

            // Size & Padding
            const iconSizeInput = document.getElementById('iconSize');
            const iconPaddingInput = document.getElementById('iconPadding');
            
            // Background
            const bgToggle = document.getElementById('bgToggle');
            const bgColorContainer = document.getElementById('bgColorContainer');
            const bgColorInput = document.getElementById('bgColor');
            const bgColorHex = document.getElementById('bgColorHex');
            const bgShapeRadios = document.querySelectorAll('input[name="bgShape"]');
            
            // Layout
            const sidebar = document.getElementById('sidebar');
            const sidebarToggle = document.getElementById('sidebarToggle');
            const sidebarOverlay = document.getElementById('sidebarOverlay');
            const sidebarCloseBtn = document.getElementById('sidebarCloseBtn');
            const sidebarContent = document.getElementById('sidebarContent'); 
            const desktopSidebarOpenBtn = document.getElementById('desktopSidebarOpenBtn'); 

            // Control Buttons
            const resetControlsBtn = document.getElementById('resetControlsBtn');
            const copyClassBtn = document.getElementById('copyClassBtn');
            const copyUnicodeBtn = document.getElementById('copyUnicodeBtn');
            const copyMessage = document.getElementById('copyMessage');
            
            // NEW: Preset Buttons
            const presetClassicBtn = document.getElementById('presetClassic');
            const presetSunsetBtn = document.getElementById('presetSunset');
            const presetGithubBtn = document.getElementById('presetGithub');
            const presetRandomBtn = document.getElementById('presetRandom');


            // --- Core UI Functions ---

            function showErrorMessage(title, message) {
                errorTitle.textContent = title;
                errorMessage.textContent = message;
                errorModal.classList.remove('hidden');
            }
            closeErrorModal.addEventListener('click', () => errorModal.classList.add('hidden'));

            function setApiLoading(isLoading) {
                const btnText = iconApiSearchBtn.querySelector('.btn-text');
                const loader = iconApiSearchBtn.querySelector('.btn-loader');
                btnText.classList.toggle('hidden', isLoading);
                loader.classList.toggle('hidden', !isLoading);
                iconApiSearchBtn.disabled = isLoading;
                iconApiSearch.disabled = isLoading;
            }

            function updateControlsState(disabled) {
                const buttons = [exportJpgBtn, exportPngBtn, copyClassBtn, copyUnicodeBtn];
                buttons.forEach(btn => {
                    btn.disabled = disabled;
                    btn.classList.toggle('opacity-50', disabled);
                    btn.classList.toggle('cursor-not-allowed', disabled);
                });
            }

            // --- Main Preview Update Function ---
            function updatePreview() {
                // 1. Update Background
                previewIconContainer.style.backgroundColor = isBgEnabled ? currentBgColor : 'transparent';
                previewIconContainer.style.borderStyle = isBgEnabled ? 'solid' : 'dashed';
                previewIconContainer.style.borderColor = isBgEnabled ? currentBgColor : '#D1D5DB'; 

                if (isBgEnabled) {
                    if (currentBgShape === 'circle') previewIconContainer.style.borderRadius = '9999px';
                    else if (currentBgShape === 'rounded') previewIconContainer.style.borderRadius = '0.75rem';
                    else previewIconContainer.style.borderRadius = '0px';
                } else {
                    previewIconContainer.style.borderRadius = '0.5rem';
                }

                // 2. Update Icon Color (Solid or Gradient)
                // MODIFICATION: Logic to show/hide and style the correct icon
                const previewContainerSize = 256; // 16rem
                const totalSize = currentSize + (currentPadding * 2);
                let previewIconSize = 0;
                if (totalSize > 0) {
                    const iconProportion = currentSize / totalSize;
                    previewIconSize = previewContainerSize * iconProportion;
                }
                
                // Apply size to both (only one will be visible)
                previewIconSolid.style.fontSize = `${previewIconSize}px`;
                previewIconGradient.style.fontSize = `${previewIconSize}px`;

                if (isGradient) {
                    // Show gradient icon, hide solid
                    previewIconSolid.classList.add('hidden');
                    previewIconGradient.classList.remove('hidden');

                    const angle = currentGradientAngle + 'deg';
                    previewIconGradient.style.background = `linear-gradient(${angle}, ${currentGradientColor1}, ${currentGradientColor2})`;
                    // 'gradient-text' class handles the rest
                } else {
                    // Show solid icon, hide gradient
                    previewIconGradient.classList.add('hidden');
                    previewIconSolid.classList.remove('hidden');

                    previewIconSolid.style.background = 'none';
                    previewIconSolid.style.color = currentGradientColor1;
                }

                // 3. Update Icon Size (Proportionally)
                // MOVED: Size logic moved up to step 2 to apply to both icons
            }

            /**
             * NEW: Updates all sidebar inputs to match the current state.
             * Crucial for presets and reset.
             */
            function updateControlInputs() {
                // Colors
                gradientColor1Input.value = currentGradientColor1;
                gradientColor1Hex.value = currentGradientColor1;
                gradientColor2Input.value = currentGradientColor2;
                gradientColor2Hex.value = currentGradientColor2;
                gradientToggle.checked = isGradient;
                gradientControlsContainer.classList.toggle('hidden', !isGradient);
                gradientAngleInput.value = currentGradientAngle;
                gradientAngleValue.textContent = currentGradientAngle;
                
                // Size/Padding
                iconSizeInput.value = currentSize;
                iconPaddingInput.value = currentPadding;
                
                // Background
                bgColorInput.value = currentBgColor;
                bgColorHex.value = currentBgColor;
                bgToggle.checked = isBgEnabled;
                bgColorContainer.classList.toggle('hidden', !isBgEnabled);
                bgShapeRadios.forEach(radio => {
                    radio.checked = (radio.value === currentBgShape);
                });
            }

            // --- Icon Data Functions ---

            function renderIconOptions(icons) {
                geminiIconGrid.innerHTML = '';
                if (!icons || icons.length === 0) {
                    geminiIconGrid.classList.add('hidden');
                    showErrorMessage("Icon Search Error", "No icons were found for that term.");
                    return;
                }
                icons.forEach(icon => {
                    if (!icon.name || !icon.class || !icon.unicode) return; 
                    const btn = document.createElement('button');
                    btn.type = 'button';
                    btn.className = 'icon-grid-btn';
                    btn.dataset.class = icon.class;
                    btn.dataset.name = icon.name;
                    btn.dataset.unicode = icon.unicode;
                    btn.setAttribute('aria-label', icon.name);
                    if (currentIcon && icon.class === currentIcon.class) {
                        btn.classList.add('selected');
                    }
                    const i = document.createElement('i');
                    i.className = icon.class;
                    btn.appendChild(i);
                    geminiIconGrid.appendChild(btn);
                });
                geminiIconGrid.classList.remove('hidden');
            }

            // MODIFIED: This function now handles showing/hiding the preview icon
            function updateIcon(icon) {
                if (!icon || !icon.class || !icon.unicode || !icon.name) {
                    currentIcon = null;
                    // MODIFICATION: Update both icons
                    previewIconSolid.className = 'hidden';
                    previewIconGradient.className = 'hidden gradient-text';
                    currentIconName.textContent = 'No icon selected';
                    updateControlsState(true);
                } else {
                    currentIcon = icon;
                    // MODIFICATION: Update classes for both icons
                    previewIconSolid.className = icon.class;
                    previewIconGradient.className = `${icon.class} gradient-text`;
                    currentIconName.textContent = icon.name;
                    updateControlsState(false);
                }
                // UpdatePreview will handle showing the correct one
                updatePreview();
            }

            // --- Sidebar & Control Logic ---
            
            function toggleMobileSidebar() {
                isMobileSidebarOpen = !isMobileSidebarOpen;
                sidebar.classList.toggle('-translate-x-full', !isMobileSidebarOpen);
                sidebarOverlay.classList.toggle('hidden', !isMobileSidebarOpen);
            }
            
            function resetControls() {
                applyPreset('classic'); // Resetting is just applying the default preset
            }

            /**
             * NEW: Applies a named preset
             */
            function applyPreset(presetName) {
                const p = presets[presetName];
                if (!p) return;
                
                // Update all state variables
                currentGradientColor1 = p.gradientColor1;
                currentGradientColor2 = p.gradientColor2;
                isGradient = p.isGradient;
                currentGradientAngle = p.gradientAngle;
                currentSize = p.size;
                currentPadding = p.padding;
                currentBgColor = p.bgColor;
                isBgEnabled = p.bgEnabled;
                currentBgShape = p.bgShape;

                // Update UI to match new state
                updateControlInputs();
                updatePreview();
            }

            /**
             * NEW: Generates and applies a random style
             */
            function randomizeStyle() {
                const randomHex = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                const shapes = ['circle', 'rounded', 'square'];

                currentGradientColor1 = randomHex();
                currentGradientColor2 = randomHex();
                isGradient = Math.random() < 0.5;
                currentGradientAngle = Math.floor(Math.random() * 360);
                
                isBgEnabled = Math.random() < 0.5;
                currentBgColor = randomHex();
                currentBgShape = shapes[Math.floor(Math.random() * shapes.length)];
                
                // Keep size/padding reasonable
                currentSize = Math.floor(Math.random() * (128 - 32 + 1)) + 32; // 32-128
                currentPadding = Math.floor(Math.random() * (32 - 8 + 1)) + 8; // 8-32

                updateControlInputs();
                updatePreview();
            }


            // --- Clipboard Logic ---

            function copyToClipboard(text) {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(showCopyMessage, () => fallbackCopyToClipboard(text));
                } else {
                    fallbackCopyToClipboard(text);
                }
            }
            function fallbackCopyToClipboard(text) {
                try {
                    clipboardFallback.value = text;
                    clipboardFallback.select();
                    document.execCommand('copy');
                    showCopyMessage();
                } catch (err) {
                    showErrorMessage("Copy Error", "Could not copy text to clipboard.");
                }
            }
            function showCopyMessage() {
                if (copyTimeout) clearTimeout(copyTimeout);
                copyMessage.classList.remove('opacity-0');
                copyTimeout = setTimeout(() => copyMessage.classList.add('opacity-0'), 2000);
            }

            // --- Initial Setup ---
            // updatePreview(); // REMOVED
            // updateControlsState(true); // REMOVED
            // previewIcon.classList.add('hidden'); // REMOVED
            updateIcon(null); // Set the initial state correctly
            updateControlInputs(); // NEW: Ensure controls match default state
            updatePreview(); // NEW: Ensure preview matches default state

            // --- Event Listeners ---

            // Layout
            // MODIFIED: Fixed the broken logic from the bad copy-paste
            sidebarToggle.addEventListener('click', toggleMobileSidebar);
            sidebarOverlay.addEventListener('click', toggleMobileSidebar);
            sidebarCloseBtn.addEventListener('click', () => {
                if (window.innerWidth < 768) {
                    toggleMobileSidebar();
                } else {
                    isDesktopSidebarOpen = false;
                    sidebar.classList.add('w-0', 'p-0');
                    // MODIFIED: Changed w-96 to w-[28rem]
                    sidebar.classList.remove('w-[28rem]', 'p-6');
                    sidebarContent.classList.add('opacity-0', 'pointer-events-none');
                    desktopSidebarOpenBtn.classList.remove('hidden');
                }
            });
            desktopSidebarOpenBtn.addEventListener('click', () => {
                isDesktopSidebarOpen = true;
                // MODIFIED: Changed w-96 to w-[28rem]
                sidebar.classList.add('w-[28rem]', 'p-6');
                sidebar.classList.remove('w-0', 'p-0');
                sidebarContent.classList.remove('opacity-0', 'pointer-events-none');
                desktopSidebarOpenBtn.classList.add('hidden');
            });
            // END OF FIX

            // Color Pickers
            gradientToggle.addEventListener('input', (e) => {
                isGradient = e.target.checked;
                gradientControlsContainer.classList.toggle('hidden', !isGradient);
                updatePreview();
            });
            const colorListener = (e, hexInput, stateKey) => {
                const color = e.target.value;
                hexInput.value = color;
                // Use a dynamic state update based on the key
                if (stateKey === 'currentGradientColor1') currentGradientColor1 = color;
                else if (stateKey === 'currentGradientColor2') currentGradientColor2 = color;
                else if (stateKey === 'currentBgColor') currentBgColor = color;
                updatePreview();
            };
            const hexListener = (e, colorInput, stateKey) => {
                const hex = e.target.value;
                if (/^#[0-9A-F]{6}$/i.test(hex)) {
                    colorInput.value = hex;
                    if (stateKey === 'currentGradientColor1') currentGradientColor1 = hex;
                    else if (stateKey === 'currentGradientColor2') currentGradientColor2 = hex;
                    else if (stateKey === 'currentBgColor') currentBgColor = hex;
                    updatePreview();
                }
            };
            
            gradientColor1Input.addEventListener('input', (e) => colorListener(e, gradientColor1Hex, 'currentGradientColor1'));
            gradientColor1Hex.addEventListener('input', (e) => hexListener(e, gradientColor1Input, 'currentGradientColor1'));
            gradientColor2Input.addEventListener('input', (e) => colorListener(e, gradientColor2Hex, 'currentGradientColor2'));
            gradientColor2Hex.addEventListener('input', (e) => hexListener(e, gradientColor2Input, 'currentGradientColor2'));
            
            gradientAngleInput.addEventListener('input', (e) => {
                currentGradientAngle = e.target.value;
                gradientAngleValue.textContent = currentGradientAngle;
                updatePreview();
            });


            // Size & Padding
            iconSizeInput.addEventListener('input', (e) => {
                let size = parseInt(e.target.value, 10);
                if (size < 16) size = 16;
                if (size > 1024) size = 1024;
                currentSize = size;
                updatePreview();
            });
            iconPaddingInput.addEventListener('input', (e) => {
                let padding = parseInt(e.target.value, 10);
                if (padding < 0) padding = 0;
                currentPadding = padding;
                updatePreview();
            });

            // Background
            bgToggle.addEventListener('input', (e) => {
                isBgEnabled = e.target.checked;
                bgColorContainer.classList.toggle('hidden', !isBgEnabled);
                updatePreview();
            });
            bgColorInput.addEventListener('input', (e) => colorListener(e, bgColorHex, 'currentBgColor'));
            bgColorHex.addEventListener('input', (e) => hexListener(e, bgColorInput, 'currentBgColor'));
            bgShapeRadios.forEach(radio => {
                radio.addEventListener('change', (e) => {
                    currentBgShape = e.target.value;
                    updatePreview();
                });
            });

            // Control Buttons
            resetControlsBtn.addEventListener('click', resetControls);
            copyClassBtn.addEventListener('click', () => currentIcon && copyToClipboard(currentIcon.class));
            copyUnicodeBtn.addEventListener('click', () => currentIcon && copyToClipboard(currentIcon.unicode));
            
            // Preset Buttons
            presetClassicBtn.addEventListener('click', () => applyPreset('classic'));
            presetSunsetBtn.addEventListener('click', () => applyPreset('sunset'));
            presetGithubBtn.addEventListener('click', () => applyPreset('github'));
            presetRandomBtn.addEventListener('click', randomizeStyle);

            // Icon Grid
            geminiIconGrid.addEventListener('click', (e) => {
                const btn = e.target.closest('.icon-grid-btn');
                if (!btn) return;
                geminiIconGrid.querySelector('.icon-grid-btn.selected')?.classList.remove('selected');
                btn.classList.add('selected');
                updateIcon(btn.dataset);
            });


            // --- Gemini API Logic ---
            iconApiSearchBtn.addEventListener('click', async () => {
                const searchTerm = iconApiSearch.value.trim();
                if (!searchTerm) {
                    showErrorMessage("Icon Search", "Please enter a search term.");
                    return;
                }
                setApiLoading(true);
                const systemPrompt = "You are a Font Awesome 6 expert. A user is searching for an icon. Based on their query, return a JSON array of up to 24 related icons. Each object in the array must have: 'name' (e.g., 'User'), 'class' (e.g., 'fa-solid fa-user', 'fa-regular fa-user', or 'fa-brands fa-github'), and 'unicode' (e.g., 'f007' or 'f09b'). Do not include 'fa-' in the name. Prioritize solid, regular, and brands styles.";
                const payload = {
                    contents: [{ parts: [{ text: `Search query: "${searchTerm}"` }] }],
                    systemInstruction: { parts: [{ text: systemPrompt }] },
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "ARRAY",
                            items: {
                                type: "OBJECT",
                                properties: {
                                    "name": { "type": "STRING" },
                                    "class": { "type": "STRING" },
                                    "unicode": { "type": "STRING" }
                                },
                                required: ["name", "class", "unicode"]
                            }
                        }
                    }
                };
                try {
                    const result = await callGeminiApi(payload);
                    const part = result.candidates?.[0]?.content.parts[0];
                    if (part && part.text) {
                        const iconData = JSON.parse(part.text);
                        if (Array.isArray(iconData) && iconData.length > 0) {
                            renderIconOptions(iconData);
                            // Select the first icon and highlight it
                            updateIcon(iconData[0]);
                            const firstButton = geminiIconGrid.querySelector('.icon-grid-btn');
                            if (firstButton) firstButton.classList.add('selected');
                        } else {
                            renderIconOptions([]); 
                            updateIcon(null); 
                        }
                    } else { throw new Error("Invalid response structure from API."); }
                } catch (error) {
                    console.error('Gemini API Error:', error);
                    showErrorMessage("Icon Search Error", "Could not find an icon for that term. Please try being more specific.");
                    updateIcon(null); 
                } finally {
                    setApiLoading(false);
                }
            });
            
            // Add keypress listener for 'Enter' on the search input
            iconApiSearch.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault(); // Stop form submission (if any)
                    iconApiSearchBtn.click(); // Trigger the search button click
                }
            });

            async function callGeminiApi(payload, retryCount = 0) {
                const MAX_RETRIES = 3;
                const apiKey = ""; // Leave empty
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (!response.ok) {
                        if (response.status === 429 && retryCount < MAX_RETRIES) {
                            const delay = Math.pow(2, retryCount) * 1000 + Math.random() * 1000;
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return callGeminiApi(payload, retryCount + 1);
                        }
                        throw new Error(`API request failed with status ${response.status}: ${await response.text()}`);
                    }
                    return await response.json();
                } catch (error) {
                    console.error("Fetch error:", error);
                    throw error;
                }
            }


            // --- Export Logic ---

            function triggerDownload(href, filename) {
                downloadLink.href = href;
                downloadLink.download = filename;
                document.body.appendChild(downloadLink);
                downloadLink.click();
                document.body.removeChild(downloadLink);
            }

            async function loadIconFont() {
                if (!currentIcon) throw new Error("No icon selected to load.");
                let fontFamily = '"Font Awesome 6 Free"', fontWeight = '900';
                if (currentIcon.class.includes('fa-brands')) {
                    fontFamily = '"Font Awesome 6 Brands"'; fontWeight = '400';
                } else if (currentIcon.class.includes('fa-regular')) {
                    fontWeight = '400';
                }
                try {
                    await document.fonts.load(`${fontWeight} 1em ${fontFamily}`);
                } catch (err) {
                    console.error("Font loading error: ", err);
                    throw new Error("Could not load the required icon font for export.");
                }
            }

            /**
             * CHANGED: Pixel-perfect export logic.
             */
            function generateIconCanvas(exportType = 'png') {
                if (!currentIcon) throw new Error("No icon selected to draw.");

                // CHANGED: Canvas size is now based on user input, not preview.
                const totalSize = currentSize + (currentPadding * 2);
                if (totalSize <= 0) throw new Error("Invalid size or padding.");

                canvas.width = totalSize;
                canvas.height = totalSize;
                ctx.clearRect(0, 0, totalSize, totalSize);

                // 1. Draw Background (if JPG or enabled)
                if (exportType === 'jpg') {
                    ctx.fillStyle = isBgEnabled ? currentBgColor : '#FFFFFF';
                    ctx.fillRect(0, 0, totalSize, totalSize);
                }

                if (isBgEnabled) {
                    ctx.fillStyle = currentBgColor;
                    if (currentBgShape === 'circle') {
                        ctx.beginPath();
                        ctx.arc(totalSize / 2, totalSize / 2, totalSize / 2, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (currentBgShape === 'rounded') {
                        const cornerRadius = totalSize * 0.125; // Proportional radius
                        if (ctx.roundRect) {
                            ctx.beginPath();
                            ctx.roundRect(0, 0, totalSize, totalSize, cornerRadius);
                            ctx.fill();
                        } else {
                            // Manual rounded rect fallback
                            ctx.beginPath();
                            ctx.moveTo(cornerRadius, 0);
                            ctx.lineTo(totalSize - cornerRadius, 0);
                            ctx.quadraticCurveTo(totalSize, 0, totalSize, cornerRadius);
                            ctx.lineTo(totalSize, totalSize - cornerRadius);
                            ctx.quadraticCurveTo(totalSize, totalSize, totalSize - cornerRadius, totalSize);
                            ctx.lineTo(cornerRadius, totalSize);
                            ctx.quadraticCurveTo(0, totalSize, 0, totalSize - cornerRadius);
                            ctx.lineTo(0, cornerRadius);
                            ctx.quadraticCurveTo(0, 0, cornerRadius, 0);
                            ctx.closePath();
                            ctx.fill();
                        }
                    } else { // 'square'
                        ctx.fillRect(0, 0, totalSize, totalSize);
                    }
                }

                // 2. Create Icon Fill (Solid or Gradient)
                let iconFill;
                if (isGradient) {
                    // Convert angle to gradient line coordinates
                    const angleRad = (currentGradientAngle * Math.PI) / 180;
                    // Fix for gradient coordinates
                    const x0 = 0.5 * totalSize * (1 - Math.cos(angleRad));
                    const y0 = 0.5 * totalSize * (1 - Math.sin(angleRad));
                    const x1 = 0.5 * totalSize * (1 + Math.cos(angleRad));
                    const y1 = 0.5 * totalSize * (1 + Math.sin(angleRad));
                    
                    iconFill = ctx.createLinearGradient(x0, y0, x1, y1);
                    iconFill.addColorStop(0, currentGradientColor1);
                    iconFill.addColorStop(1, currentGradientColor2);
                } else {
                    iconFill = currentGradientColor1;
                }
                
                // 3. Draw the Icon
                let fontFamily = '"Font Awesome 6 Free"', fontWeight = '900';
                if (currentIcon.class.includes('fa-brands')) {
                    fontFamily = '"Font Awesome 6 Brands"'; fontWeight = '400';
                } else if (currentIcon.class.includes('fa-regular')) {
                    fontWeight = '400';
                }
                
                ctx.font = `${fontWeight} ${currentSize}px ${fontFamily}`; // Use currentSize directly
                ctx.fillStyle = iconFill;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const char = String.fromCodePoint(parseInt(currentIcon.unicode, 16));
                ctx.fillText(char, totalSize / 2, totalSize / 2); // Center in the total size
            }

            const exportHandler = async (exportType) => {
                if (!currentIcon) {
                    showErrorMessage("Export Error", "Please select an icon first.");
                    return;
                }
                loadingOverlay.classList.remove('hidden');
                try {
                    await loadIconFont();
                    generateIconCanvas(exportType);
                    const mimeType = exportType === 'jpg' ? 'image/jpeg' : 'image/png';
                    const quality = exportType === 'jpg' ? 0.95 : 1.0; // High quality JPG
                    const dataUri = canvas.toDataURL(mimeType, quality);
                    const filename = `${currentIcon.name.toLowerCase().replace(/ /g, '-')}-icon.${exportType}`;
                    triggerDownload(dataUri, filename);
                } catch (error) {
                    console.error(`${exportType.toUpperCase()} Export Error:`, error);
                    showErrorMessage("Export Error", error.message);
                } finally {
                    loadingOverlay.classList.add('hidden');
                }
            };
            
            exportPngBtn.addEventListener('click', () => exportHandler('png'));
            exportJpgBtn.addEventListener('click', () => exportHandler('jpg'));
        });
    </script>

</body>
</html>

